{#include internalheader title="Contract" /}{|

<div style="font-size: small;">
    Fetched in {{ timeTaken }}ms
</div>

<mf-contract v-if="model.contract.id" :contract="model.contract" allow-accept-offer="true" @accepted="acceptedOffer"></mf-contract>
<div v-if="model.contract.createdBy">Created by {{model.contract.createdBy}} at {{model.contract.createdAt}}</div>
<div v-if="model.contract.offeredBy">Offered by {{model.contract.offeredBy}} at {{model.contract.offeredAt}}</div>
<div v-if="model.contract.acceptedBy">Accepted by {{model.contract.acceptedBy}} at {{model.contract.acceptedAt}}</div>
<div v-if="model.contract.approvedBy">Approved by {{model.contract.approvedBy}} at {{model.contract.approvedAt}}</div>
<div v-if="model.contract.contractState == 'DRAFT'">
    <p-button id="offerDraftButton" @click="offerDraft()">Offer draft</p-button>
</div>
<div v-if="model.contract.contractState == 'AWAITING_APPROVAL'">
    |}{! TODO add a text field where the user can justify this !}{|
    <p-button id="approveContractButton" @click="approveContract()">Approve contract</p-button>
</div>
<hr>
<div>
    <ul>
        <li v-for="component in model.contract.components">
            <div>{{component.componentDefinitionId}}</div>
            <ul>
                <li v-for="config in component.configs">{{config.name}} {{config.value}} {{config.units}}</li>
            </ul>
        </li>
    </ul>
</div>
<hr>
<mf-partner v-for="partnerRelationship in model.partnerRelationships"
            :partner-id="partnerRelationship.partnerId"
            :role="partnerRelationship.role"
            clickable="true"
            @loaded="partnerLoaded">
</mf-partner>

</span>
<span>
    <mf-cases :case-reference-ids="model.allContractIds"></mf-cases>
</span>
</div>
</div> |}{! end of app div !}{|
<script>
var urlParams = new URLSearchParams(window.location.search);
var id = urlParams.get('id');
console.log("using id from url: " + id);

const App = {
    data() {
        return {
            model: { id, contract: {} },
            start: 0,
            timeTaken: 0,
            requestId: uuidv4(),
            users
        }
    },
    mounted() {
        window.model = this.model; // just for debugging purposes
        eventHub.on(LOGGED_IN, (username) => {
            // re-fetch when trying a different user, to e.g. re-render how tasks are shown for
            // that user, as well as re-check security
            this.fetchContract();
        });
    },
    methods: {
        fetchContract() {
            let self = this;
            let url = CONTRACTS_BASE_URL + "/contracts/" + this.model.id + "?withDetails=true";
            let contract$ = fetchIt(url, "GET", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    self.model.contract = r.payload;
                    self.model.allContractIds = [id];
                    console.log("got contract with id " + r.payload.id + ", for requestId " + self.requestId);
                } else {
                    let msg = "Failed to get contract: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });

            url = PARTNERS_BASE_URL + "/partner-relationships/latestByForeignId/" + this.model.id + "/*?idsOnly=false";
            let partnerRelationships$ = fetchIt(url, "GET", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    console.log("got partner-relationships, for requestId " + self.requestId);
                    self.model.partnerRelationships = r.payload;
                } else {
                    let msg = "Failed to get partner relationships: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });

            return Promise.all([contract$, partnerRelationships$]);
        },
        approveContract() {
            let self = this;
            let url = CONTRACTS_BASE_URL + "/contracts/approve/" + this.model.id;
            let contract$ = fetchIt(url, "PUT", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    // dont lose the components (details), as they are not returned in this call
                    r.payload.components = self.model.contract.components;
                    self.model.contract = r.payload;
                    console.log("got contract with id " + r.payload.id + ", for requestId " + self.requestId);
                    self.model.allContractIds = [self.model.contract.id];
                } else {
                    let msg = "Failed to get contract: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });
        },
        partnerLoaded() {
            this.timeTaken = new Date().getTime() - this.start;
        },
        offerDraft() {
            console.log("offering contract...")
            let self = this;
            let url = CONTRACTS_BASE_URL + "/drafts/" + this.model.id + "/offer";
            fetchIt(url, "PUT", this).then(r => {
                if(r.ok) {
                    // dont lose the components (details), as they are not returned in this call
                    r.payload.components = self.model.contract.components;
                    self.model.contract = r.payload;
                    console.log("offered contract with id " + self.model.contract.id);
                } else {
                    if(r.payload.class == "ch.maxant.kdc.mf.partners.boundary.NoRelationshipsFoundValidationException") {
                        alert("No partner relationships exist, please create a new offer");
                    } else if(r.payload.class == "ch.maxant.kdc.mf.partners.boundary.NotEnoughRelationshipsForForeignIdTypeValidationException") {
                        alert("A partner relationship is missing: " + r.payload.data);
                    } else {
                        let msg = "Failed to offer contract: " + r.payload;
                        console.error(msg);
                        alert(msg);
                    }
                }
            }).catch(error => {
                console.error("received error: " + error);
            });
        },
        acceptedOffer(contract) {
            // dont lose the components (details), as they are not returned in this call
            contract.components = this.model.contract.components;
            this.model.contract = contract;
            this.model.allContractIds = [contract.id];
        }
    },
    components: {
        'p-button': button,
        'mf-partner': mfPartnerTile,
        'mf-contract': mfContractTile,
        'mf-users': mfUsers,
        'mf-cases': mfCases
    }
}
const app = Vue.createApp(App)
app.use(primevue);
app.mount("#app")

</script>


|}{#include internalfooter /}
