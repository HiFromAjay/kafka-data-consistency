{#include internalheader title="Contract" /}{|

<div style="font-size: small;">
    Fetched in {{ timeTaken }}ms
</div>

<div class="p-grid">
    <mf-contract v-if="model.contract.id" :contract="model.contract" allow-accept-offer="true" @accepted="acceptedOffer" source="graphql+cache"></mf-contract>
    <mf-partner v-for="partnerRelationship in model.partnerRelationships"
                :partner-id="partnerRelationship.partnerId"
                :role="partnerRelationship.role"
                clickable="true"
                @loaded="partnerLoaded">
    </mf-partner>
</div>
<hr>
<div>
    <div v-if="model.contract.createdBy">Created by {{model.contract.createdBy}} at {{model.contract.createdAt}}</div>
    <div v-if="model.contract.offeredBy">Offered by {{model.contract.offeredBy}} at {{model.contract.offeredAt}}</div>
    <div v-if="model.contract.acceptedBy">Accepted by {{model.contract.acceptedBy}} at {{model.contract.acceptedAt}}</div>
    <div v-if="model.contract.approvedBy">Approved by {{model.contract.approvedBy}} at {{model.contract.approvedAt}}</div>
    <div v-if="model.contract.state == 'DRAFT'">     |}{! we can use "state" or "contractState" - see graphQl mapping in request below !}{|
        <p-button id="offerDraftButton" @click="offerDraft()">Offer draft</p-button>
        <p-button v-if="showResync" @click="resync()">resync</p-button>

    </div>
    <div v-if="model.contract.contractState == 'AWAITING_APPROVAL'">
        |}{! TODO add a text field where the user can justify this !}{|
        <p-button id="approveContractButton" @click="approveContract()">Approve contract</p-button>
    </div>
</div>
<hr>
<div class="p-grid">
    <div class="p-col-12 p-sm-12 p-md-6 p-lg-4 p-xl-4">
        <div>
            <h3>Components</h3>
            <ul>
                <li v-for="component in model.contract.components">
                    <div>{{component.componentDefinitionId}} ({{parseFloat(component.$price).toFixed(2)}} CHF)</div>
                    <ul>
                        <li v-for="config in component.configs">
                            {{toLower(config.name)}} {{toLower(config.value)}} {{config.units == 'NONE'?'':toLower(config.units)}}
                        </li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    <div class="p-col-12 p-sm-12 p-md-6 p-lg-4 p-xl-4">
        <div>
            <h3>Discounts and Surcharges</h3>
            <span v-if="model.discountssurcharges.failedReason">Currently unavailable: {{model.discountssurcharges.failedReason}}</span>
            <ul v-else-if="model.discountssurcharges && model.discountssurcharges.list && model.discountssurcharges.list.length > 0">
                <li v-else v-for="discountsurcharge in model.discountssurcharges.list">
                    {{discountsurcharge.definitionId}}:
                    {{Math.abs(discountsurcharge.value*100)}}%
                    {{discountsurcharge.value < 0 ? "discount" : "surcharge"}}
                    on {{getComponentName(discountsurcharge.componentId)}}
                    added {{discountsurcharge.addedManually ? "manually" : "automatically"}}
                </li>
            </ul>
            <span v-else>None</span>
        </div>
        <hr>
        <div>
            <h3>Conditions</h3>
            <span v-if="model.conditions.failedReason">Currently unavailable: {{model.conditions.failedReason}}</span>
            <ul v-else-if="model.conditions && model.conditions.list && model.conditions.list.length > 0">
                <li v-else v-for="condition in model.conditions.list">
                    "{{condition.definitionId}}"
                    on {{getComponentName(condition.componentId)}}
                    added {{condition.addedManually ? "manually" : "automatically"}}
                </li>
            </ul>
            <span v-else>None</span>
        </div>
        <hr>
        <div>
            <h3>Bills</h3>
            <table v-if="model.bills.length > 0" border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse;">
                <tr>
                    <th>Billing Definition</th>
                    <th>Start</th>
                    <th>End</th>
                    <th>Price</th>
                    <th>Created At</th>
                </tr>
                <tr v-for="bill in model.bills">
                    <td>{{bill.definitionId}}</td>
                    <td>{{bill.start}}</td>
                    <td>{{bill.end}}</td>
                    <td>{{bill.price}}</td>
                    <td>{{bill.createdAt}}</td>
                </tr>
            </table>
            <span v-else>None</span>
        </div>
    </div>
</div>

<hr>
<mf-cases :case-reference-ids="model.allContractIds"></mf-cases>
<hr>
<div>
    <p-button @click="evictFromCache()">cache evict</p-button>
</div>

</span>
</div>
</div> |}{! end of app div !}{|
<script>
var urlParams = new URLSearchParams(window.location.search);
var id = urlParams.get('id');
console.log("using id from url: " + id);

const App = {
    data() {
        return {
            model: { id, contract: {}, partnerRelationships: [], discountssurcharges: [], conditions: [], bills: [] },
            showResync: false,
            start: 0,
            timeTaken: 0,
            requestId: uuidv4(),
            users
        }
    },
    mounted() {
        window.model = this.model; // just for debugging purposes
        eventHub.on(LOGGED_IN, (username) => {
            // re-fetch when trying a different user, to e.g. re-render how tasks are shown for
            // that user, as well as re-check security
            this.fetchContract();
        });
    },
    methods: {
        fetchContract() {
            let self = this;

            let query = `
                query {
                    cached_aggregate(id: "${this.model.id}") {
                        contract {
                            createdAt createdBy offeredAt offeredBy acceptedAt acceptedBy approvedAt approvedBy id start end contractState state:contractState
                            components {
                                id parentId productId componentDefinitionId configs {name, value, units }
                            }
                        }
                        discountsAndSurcharges { failedReason list { componentId addedManually definitionId value } }
                        conditions { failedReason list { componentId addedManually definitionId } }
                        anythingMissing
                    }
                }`;
            let body = { query };
            let url = CONTRACTS_BASE_URL + "/graphql";
            let aggregate$ = fetchIt(url, "POST", this, body).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok && !r.payload.errors) {
                    self.model.contract = r.payload.data.cached_aggregate.contract;
                    self.model.allContractIds = [id];
                    self.model.discountssurcharges = r.payload.data.cached_aggregate.discountsAndSurcharges;
                    self.model.conditions = r.payload.data.cached_aggregate.conditions;
                    console.log("got aggregate for requestId " + self.requestId);
                } else {
                    let msg = "Failed to get aggregate: " + JSON.stringify(r.payload);
                    console.error(msg);
                    alert(msg);
                }
            }).then(r => {
                return self.getPrices();
            }).catch(error => {
                alert("received error: " + error);
            });

            url = PARTNERS_BASE_URL + "/partner-relationships/latestByForeignId/" + this.model.id + "/*?idsOnly=false";
            let partnerRelationships$ = fetchIt(url, "GET", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    console.log("got partner-relationships, for requestId " + self.requestId);
                    self.model.partnerRelationships = _.sortBy(r.payload, 'role');
                } else {
                    let msg = "Failed to get partner relationships: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });

            url = BILLING_BASE_URL + "/billing/findByContractId?contractIds=" + this.model.id;
            let bills$ = fetchIt(url, "GET", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    console.log("got bills, for requestId " + self.requestId);
                    self.model.bills = r.payload;
                } else {
                    let msg = "Failed to get bills: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });

            return Promise.all([aggregate$, partnerRelationships$, bills$]);
        },
        getPrices() {
            let self = this;
            let url = PRICING_BASE_URL + "/pricing/prices/" + self.model.id + "?dateTime=" + self.model.contract.end;
            return fetchIt(url, "GET", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    console.log("got prices, for requestId " + self.requestId);
                    self.model.prices = r.payload;
                    self.model.prices.forEach(p => {
                        self.model.contract.components.forEach(c => {
                            if(c.id == p.componentId) {
                                c.$price = p.price;
                            }
                        });
                    });
                } else {
                    let msg = "Failed to get prices: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });

            return Promise.all([aggregate$, partnerRelationships$, bills$]);
        },
        approveContract() {
            let self = this;
            let url = CONTRACTS_BASE_URL + "/contracts/approve/" + this.model.id;
            let contract$ = fetchIt(url, "PUT", this).then(r => {
                self.timeTaken = new Date().getTime() - self.start;
                if(r.ok) {
                    // dont lose the components (details), as they are not returned in this call
                    r.payload.components = self.model.contract.components;
                    self.model.contract = r.payload;
                    console.log("got contract with id " + r.payload.id + ", for requestId " + self.requestId);
                    self.model.allContractIds = [self.model.contract.id];
                } else {
                    let msg = "Failed to approve contract: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                alert("received error: " + error);
            });
        },
        partnerLoaded() {
            this.timeTaken = new Date().getTime() - this.start;
        },
        offerDraft() {
            console.log("offering contract...")
            let self = this;
            let url = CONTRACTS_BASE_URL + "/drafts/" + this.model.id + "/offer";
            fetchIt(url, "PUT", this).then(r => {
                if(r.ok) {
                    // dont lose the components (details), as they are not returned in this call
                    r.payload.components = self.model.contract.components;
                    self.model.contract = r.payload;
                    console.log("offered contract with id " + self.model.contract.id);
                } else {
                    if(!_.isObject(r.payload)) { r.payload = JSON.parse(r.payload); }
                    if(r.payload.class == "ch.maxant.kdc.mf.partners.boundary.NoRelationshipsFoundValidationException") {
                        alert("No partner relationships exist, please create a new offer");
                    } else if(r.payload.class == "ch.maxant.kdc.mf.partners.boundary.NotEnoughRelationshipsForForeignIdTypeValidationException") {
                        alert("A partner relationship is missing: " + r.payload.data);
                    } else if(r.payload.error.indexOf("is not in sync with the contract") >= 0) {
                        self.showResync = true;
                        alert("The discounts/surcharges/conditions/price are not in sync - please recalculate them using the 'resync' button provided.");
                    } else {
                        let msg = "Failed to offer contract: " + r.payload;
                        console.error(msg);
                        alert(msg);
                        self.showResync = true;
                    }
                }
            }).catch(error => {
                console.error("received error: " + error);
            });
        },
        resync() {
            console.log("resyncing contract")
            let self = this;
            let url = CONTRACTS_BASE_URL + "/drafts/" + this.model.id + "/resync";
            fetchIt(url, "PUT", this).then(r => {
                if(r.ok) {
                    // dont lose the components (details), as they are not returned in this call
                    r.payload.components = self.model.contract.components;
                    self.model.contract = r.payload;
                    console.log("resynced");
                    self.showResync = false;
                } else {
                    let msg = "Failed: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                console.error("received error: " + error);
            });
        },
        acceptedOffer(contract) {
            // dont lose the components (details), as they are not returned in this call
            contract.components = this.model.contract.components;
            this.model.contract = contract;
            this.model.allContractIds = [contract.id];
        },
        getComponentName(componentId) {
            return _.find(this.model.contract.components, c => c.id == componentId).componentDefinitionId;
        },
        evictFromCache() {
            console.log("evicting from cache...")
            let self = this;
            let url = ELASTICSEARCH_BASE_URL + "/contract-cache/_doc/" + this.model.id;
            fetchIt(url, "DELETE", this).then(r => {
                if(r.ok) {
                    console.log("cleared cache");
                } else {
                    let msg = "Failed to clear cache: " + r.payload;
                    console.error(msg);
                    alert(msg);
                }
            }).catch(error => {
                console.error("received error: " + error);
            });
        },
        toLower(o) {
            return _.toLower(o);
        }
    },
    components: {
        'p-button': button,
        'mf-partner': mfPartnerTile,
        'mf-contract': mfContractTile,
        'mf-users': mfUsers,
        'mf-cases': mfCases
    }
}
const app = Vue.createApp(App)
app.use(primevue);
app.mount("#app")

</script>


|}{#include internalfooter /}
